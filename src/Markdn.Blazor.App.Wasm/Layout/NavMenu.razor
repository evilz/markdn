<div class="top-row ps-3 navbar navbar-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="">Markdn.Blazor.App.Wasm</a>
        <button title="Navigation menu" class="navbar-toggler" @onclick="ToggleNavMenu">
            <span class="navbar-toggler-icon"></span>
        </button>
    </div>
</div>

<div class="@NavMenuCssClass nav-scrollable" @onclick="ToggleNavMenu">
    <nav class="nav flex-column">
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="" Match="NavLinkMatch.All">
                <span class="bi bi-house-door-fill-nav-menu" aria-hidden="true"></span> Home
            </NavLink>
        </div>

        @if (Routes != null && Routes.Count > 0)
        {
            foreach (var r in Routes)
            {
                <div class="nav-item px-3">
                    <NavLink class="nav-link" href="@r.Route">
                        <span class="bi bi-file-earmark-text-fill-nav-menu" aria-hidden="true"></span> @r.Name
                    </NavLink>
                </div>
            }
        }
        else
        {
            <div class="nav-item px-3">
                <NavLink class="nav-link" href="counter">
                    <span class="bi bi-plus-square-fill-nav-menu" aria-hidden="true"></span> Counter
                </NavLink>
            </div>

            <div class="nav-item px-3">
                <NavLink class="nav-link" href="weather">
                    <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Weather
                </NavLink>
            </div>
        }
    </nav>
</div>

@code {
    private bool collapseNavMenu = true;

    private string? NavMenuCssClass => collapseNavMenu ? "collapse" : null;

    private void ToggleNavMenu()
    {
        collapseNavMenu = !collapseNavMenu;
    }
    
    private List<(string Route, string Name)> Routes { get; set; } = new();

    [Microsoft.AspNetCore.Components.Inject]
    private System.Net.Http.HttpClient Http { get; set; } = default!;

    protected override async System.Threading.Tasks.Task OnInitializedAsync()
    {
        // Try to load build-time manifest first
        try
        {
            var manifest = await Http.GetFromJsonAsync<List<PageManifestEntry>>("_page-manifest.json");
            if (manifest != null && manifest.Count > 0)
            {
                Routes = manifest.Select(m => (Route: m.route, Name: m.title)).ToList();
                return;
            }
        }
        catch
        {
            // ignore fetch failure and fall back to reflection
        }

        // Fallback to reflection-based discovery (previous behavior)
        await System.Threading.Tasks.Task.Run(() =>
        {
            try
            {
                var routes = new List<(string Route, string Name)>();
                var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                var assemblies = new List<System.Reflection.Assembly>();
                try { assemblies.Add(typeof(App).Assembly); } catch { }
                assemblies.AddRange(AppDomain.CurrentDomain.GetAssemblies());

                foreach (var asm in assemblies)
                {
                    Type[] types;
                    try { types = asm.GetTypes(); } catch { continue; }

                    foreach (var t in types)
                    {
                        try
                        {
                            var attrs = t.GetCustomAttributesData();
                            foreach (var ad in attrs)
                            {
                                if (string.Equals(ad.AttributeType.FullName, "Microsoft.AspNetCore.Components.RouteAttribute", StringComparison.Ordinal))
                                {
                                    string? template = null;
                                    if (ad.ConstructorArguments.Count > 0 && ad.ConstructorArguments[0].Value is string s) template = s;
                                    else
                                    {
                                        foreach (var na in ad.NamedArguments)
                                        {
                                            if (na.MemberName == "Template" && na.TypedValue.Value is string ss) { template = ss; break; }
                                        }
                                    }

                                    if (!string.IsNullOrWhiteSpace(template) && !seen.Contains(template))
                                    {
                                        string name = t.Name;
                                        try
                                        {
                                            var titleProp = t.GetProperty("Title", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
                                            if (titleProp != null && titleProp.PropertyType == typeof(string))
                                            {
                                                var v = titleProp.GetValue(null) as string;
                                                if (!string.IsNullOrWhiteSpace(v)) name = v;
                                            }
                                        }
                                        catch { }

                                        routes.Add((template, name));
                                        seen.Add(template);
                                    }
                                }
                            }
                        }
                        catch { }
                    }
                }

                Routes = routes.GroupBy(r => r.Route).Select(g => g.First()).OrderBy(r => r.Route).ToList();
            }
            catch { Routes = new List<(string Route, string Name)>(); }
        });
    }

    private class PageManifestEntry { public string route { get; set; } = string.Empty; public string title { get; set; } = string.Empty; public string file { get; set; } = string.Empty; }
}
