using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Markdn.SourceGenerators.Generators;

namespace Markdn.SourceGenerators;

/// <summary>
/// Incremental generator that discovers user-defined content models decorated with
/// <c>[Collection]</c> and emits typed services that can enumerate markdown files
/// matching the provided glob pattern.
/// </summary>
[Generator]
public sealed class ContentCollectionsGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "Markdn.Content.CollectionAttribute";
    private const string AttributeSource = @"// <auto-generated />
#nullable enable
namespace Markdn.Content;

[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
public sealed class CollectionAttribute : System.Attribute
{
    public CollectionAttribute(string globPattern)
    {
        GlobPattern = globPattern ?? string.Empty;
    }

    /// <summary>
    /// Glob pattern relative to the project directory that points to markdown files.
    /// </summary>
    public string GlobPattern { get; }

    /// <summary>
    /// Optional logical name for the collection. When omitted the model type name is used.
    /// </summary>
    public string? Name { get; set; }
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx =>
            ctx.AddSource("CollectionAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8)));

        var projectInfo = context.AnalyzerConfigOptionsProvider.Select(static (opts, _) =>
        {
            opts.GlobalOptions.TryGetValue("build_property.projectdir", out var projectDir);
            opts.GlobalOptions.TryGetValue("build_property.RootNamespace", out var rootNamespace);
            return new ProjectInfo(projectDir, rootNamespace);
        });

        var markdownFiles = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith(".md", StringComparison.OrdinalIgnoreCase))
            .Select(static (text, _) => new MarkdownFile(text.Path))
            .Collect();

        var collections = context.SyntaxProvider.ForAttributeWithMetadataName(
                AttributeFullName,
                static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (ctx, _) => CreateCollectionDeclaration(ctx))
            .Where(static info => info is not null)!
            .Collect();

        var combined = collections
            .Combine(markdownFiles)
            .Combine(projectInfo)
            .Combine(context.CompilationProvider);

        context.RegisterSourceOutput(combined, static (spc, data) =>
        {
            var (((collectionInfos, markdown), project), compilation) = data;
            if (collectionInfos.IsDefaultOrEmpty)
            {
                return;
            }

            var rootNamespace = !string.IsNullOrWhiteSpace(project.RootNamespace)
                ? project.RootNamespace!.Trim()
                : compilation.AssemblyName ?? "GeneratedContent";

            var resolvedFiles = ResolveMarkdownFiles(markdown, project.ProjectDir, rootNamespace);

            var distinctCollections = collectionInfos
                .Where(static c => c is not null && !string.IsNullOrWhiteSpace(c.GlobPattern))
                .Select(static c => c!)
                .Distinct(CollectionDeclaration.Comparer)
                .ToImmutableArray();

            foreach (var declaration in distinctCollections)
            {
                GenerateCollectionSource(spc, rootNamespace, resolvedFiles, declaration);
            }
        });
    }

    private static void GenerateCollectionSource(
        SourceProductionContext context,
        string rootNamespace,
        IReadOnlyList<ResolvedMarkdownFile> files,
        CollectionDeclaration declaration)
    {
        var globRegex = CreateGlobRegex(declaration.GlobPattern);
        if (globRegex is null)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                Descriptors.InvalidGlobPattern,
                declaration.Location,
                declaration.GlobPattern));
            return;
        }

        var matchingFiles = files
            .Where(file => globRegex.IsMatch(file.NormalizedRelativePath))
            .ToList();

        if (matchingFiles.Count == 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                Descriptors.NoMatchingMarkdownFiles,
                declaration.Location,
                declaration.GlobPattern));
        }

        var serviceBaseName = !string.IsNullOrWhiteSpace(declaration.CollectionName)
            ? ToPascalCase(declaration.CollectionName!)
            : declaration.TypeSymbolName;

        if (string.IsNullOrWhiteSpace(serviceBaseName))
        {
            serviceBaseName = declaration.TypeSymbolName;
        }

        var interfaceName = $"I{serviceBaseName}Service";
        var className = $"{serviceBaseName}Service";
        var typeName = declaration.FullyQualifiedTypeName;

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated by Markdn.SourceGenerators />");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Globalization;");
        builder.AppendLine("using System.IO;");
        builder.AppendLine("using System.Linq;");
        builder.AppendLine("using System.Reflection;");
        builder.AppendLine("using System.Text;");
        builder.AppendLine("using Microsoft.AspNetCore.Components;");
        builder.AppendLine("using Microsoft.AspNetCore.Components.Rendering;");
        builder.AppendLine();
        builder.AppendLine($"namespace {rootNamespace}.Content;");
        builder.AppendLine();
        builder.AppendLine($"public interface {interfaceName}");
        builder.AppendLine("{");
        builder.AppendLine($"    List<{typeName}> GetCollection();");
        builder.AppendLine($"    {typeName}? GetEntry(string slug);");
        builder.AppendLine("    RenderFragment? GetComponent(string slug);");
        builder.AppendLine("}");
        builder.AppendLine();
        builder.AppendLine($"public sealed class {className} : {interfaceName}");
        builder.AppendLine("{");
        builder.AppendLine($"    private readonly Lazy<CollectionCache> _cache = new(() => LoadCollection());");
        builder.AppendLine();
        builder.AppendLine($"    public List<{typeName}> GetCollection()");
        builder.AppendLine("    {");
        builder.AppendLine("        return _cache.Value.Items;");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine($"    public {typeName}? GetEntry(string slug)");
        builder.AppendLine("    {");
        builder.AppendLine("        if (string.IsNullOrWhiteSpace(slug))");
        builder.AppendLine("        {");
        builder.AppendLine("            return null;");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine("        return _cache.Value.Lookup.TryGetValue(slug, out var entry) ? entry : null;");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    public RenderFragment? GetComponent(string slug)");
        builder.AppendLine("    {");
        builder.AppendLine("        if (string.IsNullOrWhiteSpace(slug))");
        builder.AppendLine("        {");
        builder.AppendLine("            return null;");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine("        return _cache.Value.Components.TryGetValue(slug, out var fragment) ? fragment : null;");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    private static CollectionCache LoadCollection()");
        builder.AppendLine("    {");
        builder.AppendLine($"        var items = new List<{typeName}>();");
        builder.AppendLine($"        var lookup = new Dictionary<string, {typeName}>(StringComparer.OrdinalIgnoreCase);");
        builder.AppendLine("        var components = new Dictionary<string, RenderFragment>(StringComparer.OrdinalIgnoreCase);");
        builder.AppendLine($"        var assembly = typeof({typeName}).Assembly;");
        builder.AppendLine();
        builder.AppendLine("        foreach (var descriptor in _resources)");
        builder.AppendLine("        {");
        builder.AppendLine("            try");
        builder.AppendLine("            {");
        builder.AppendLine("                using var stream = OpenResourceStream(assembly, descriptor);");
        builder.AppendLine("                if (stream is null)");
        builder.AppendLine("                {");
        builder.AppendLine("                    continue;");
        builder.AppendLine("                }");
        builder.AppendLine();
        builder.AppendLine("                using var reader = new StreamReader(stream, Encoding.UTF8);");
        builder.AppendLine("                var content = reader.ReadToEnd();");
        builder.AppendLine();
        builder.AppendLine("                var parsed = ParseMarkdownFile(content, descriptor.Slug);");
        builder.AppendLine("                if (parsed is null)");
        builder.AppendLine("                {");
        builder.AppendLine("                    continue;");
        builder.AppendLine("                }");
        builder.AppendLine();
        builder.AppendLine("                items.Add(parsed.Value.Entry);");
        builder.AppendLine("                if (!lookup.ContainsKey(parsed.Value.Slug))");
        builder.AppendLine("                {");
        builder.AppendLine("                    lookup[parsed.Value.Slug] = parsed.Value.Entry;");
        builder.AppendLine("                }");
        builder.AppendLine("                if (!components.ContainsKey(parsed.Value.Slug))");
        builder.AppendLine("                {");
        builder.AppendLine("                    components[parsed.Value.Slug] = descriptor.ComponentFragment;");
        builder.AppendLine("                }");
        builder.AppendLine("            }");
        builder.AppendLine("            catch (Exception ex)");
        builder.AppendLine("            {");
        builder.AppendLine("                // Ignore malformed entries, but log for debugging");
        builder.AppendLine("                System.Diagnostics.Debug.WriteLine($\"Malformed entry ignored: {ex.Message}\");");
        builder.AppendLine("            }");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine("        return new CollectionCache(items, lookup, components);");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    private static Stream? OpenResourceStream(Assembly assembly, ResourceDescriptor descriptor)");
        builder.AppendLine("    {");
        builder.AppendLine("        var stream = assembly.GetManifestResourceStream(descriptor.ResourceName);");
        builder.AppendLine("        if (stream is not null)");
        builder.AppendLine("        {");
        builder.AppendLine("            return stream;");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine("        var fallback = assembly.GetManifestResourceNames()");
        builder.AppendLine("            .FirstOrDefault(name => name.EndsWith(descriptor.ResourceSuffix, StringComparison.OrdinalIgnoreCase));");
        builder.AppendLine("        return fallback is null ? null : assembly.GetManifestResourceStream(fallback);");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    private static ParseResult? ParseMarkdownFile(string content, string fallbackSlug)");
        builder.AppendLine("    {");
        builder.AppendLine("        if (!content.StartsWith(\"---\", StringComparison.Ordinal))");
        builder.AppendLine("        {");
        builder.AppendLine("            return null;");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine("        var secondDelimiter = content.IndexOf(\"---\", 3, StringComparison.Ordinal);");
        builder.AppendLine("        if (secondDelimiter < 0)");
        builder.AppendLine("        {");
        builder.AppendLine("            return null;");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine("        var frontMatter = content.Substring(3, secondDelimiter - 3);");
        builder.AppendLine("        var body = content.Substring(secondDelimiter + 3).Trim();");
        builder.AppendLine("        var fields = ParseFrontMatter(frontMatter);");
        builder.AppendLine("        var slug = fields.TryGetValue(\"slug\", out var slugValue) && !string.IsNullOrWhiteSpace(slugValue)");
        builder.AppendLine("            ? slugValue");
        builder.AppendLine("            : fallbackSlug;");
        builder.AppendLine();
        builder.AppendLine($"        var entry = new {typeName}");
        builder.AppendLine("        {");

        BuildPropertyAssignments(builder, declaration.Properties);

        builder.AppendLine("        };");
        builder.AppendLine();
        builder.AppendLine("        return new ParseResult(entry, slug);");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    private static Dictionary<string, string> ParseFrontMatter(string frontMatter)");
        builder.AppendLine("    {");
        builder.AppendLine("        var result = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);");
        builder.AppendLine("        var lines = System.Text.RegularExpressions.Regex.Split(frontMatter, @\"\\r\\n|\\n|\\r\").Where(l => !string.IsNullOrWhiteSpace(l));");
        builder.AppendLine();
        builder.AppendLine("        foreach (var line in lines)");
        builder.AppendLine("        {");
        builder.AppendLine("            var colonIndex = line.IndexOf(':');");
        builder.AppendLine("            if (colonIndex < 0)");
        builder.AppendLine("            {");
        builder.AppendLine("                continue;");
        builder.AppendLine("            }");
        builder.AppendLine();
        builder.AppendLine("            var key = line.Substring(0, colonIndex).Trim();");
        builder.AppendLine("            var value = line.Substring(colonIndex + 1).Trim().Trim('\"').Trim('\'');");
        builder.AppendLine("            result[key] = value;");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine("        return result;");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    private readonly record struct ParseResult(");
        builder.AppendLine($"        {typeName} Entry,");
        builder.AppendLine("        string Slug);");
        builder.AppendLine();
        builder.AppendLine("    private sealed class CollectionCache");
        builder.AppendLine("    {");
        builder.AppendLine($"        public CollectionCache(List<{typeName}> items, Dictionary<string, {typeName}> lookup, Dictionary<string, RenderFragment> components)");
        builder.AppendLine("        {");
        builder.AppendLine("            Items = items;");
        builder.AppendLine("            Lookup = lookup;");
        builder.AppendLine("            Components = components;");
        builder.AppendLine("        }");
        builder.AppendLine();
        builder.AppendLine($"        public List<{typeName}> Items {{ get; }}");
        builder.AppendLine($"        public Dictionary<string, {typeName}> Lookup {{ get; }}");
        builder.AppendLine("        public Dictionary<string, RenderFragment> Components { get; }");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    private readonly record struct ResourceDescriptor(string ResourceName, string ResourceSuffix, string Slug, RenderFragment ComponentFragment);");
        builder.AppendLine();
        builder.AppendLine("    private static readonly ResourceDescriptor[] _resources = new[]");
        builder.AppendLine("    {");

        if (matchingFiles.Count > 0)
        {
            foreach (var file in matchingFiles)
            {
                var resourceName = $"{rootNamespace}.{file.ResourceSuffix}";
                var resourceLiteral = EscapeForStringLiteral(resourceName);
                var suffixLiteral = EscapeForStringLiteral(file.ResourceSuffix);
                var slugLiteral = EscapeForStringLiteral(file.Slug);
                var componentLiteral = $"global::{file.ComponentFullTypeName}";
                builder.AppendLine($"        new ResourceDescriptor(\"{resourceLiteral}\", \"{suffixLiteral}\", \"{slugLiteral}\", builder =>");
                builder.AppendLine("        {");
                builder.AppendLine($"            builder.OpenComponent<{componentLiteral}>(0);");
                builder.AppendLine("            builder.CloseComponent();");
                builder.AppendLine("        }),");
            }
        }

        builder.AppendLine("    };");
        builder.AppendLine("}");
        builder.AppendLine();

        context.AddSource($"Collections.{serviceBaseName}.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    private static void BuildPropertyAssignments(StringBuilder builder, ImmutableArray<PropertyDescriptor> properties)
    {
        if (properties.Length == 0)
        {
            return;
        }

        foreach (var property in properties)
        {
            if (property.IsSlug)
            {
                builder.AppendLine($"            {property.Name} = slug,");
                continue;
            }

            if (property.IsContent)
            {
                builder.AppendLine($"            {property.Name} = body,");
                continue;
            }

            var variableBase = ToCamelCase(property.Name);
            var rawVariable = $"{variableBase}Raw";
            var parsedVariable = $"{variableBase}Parsed";
            var key = property.FrontMatterKey;

            switch (property.Kind)
            {
                case PropertyValueKind.String:
                    var fallback = property.IsNullable ? "null" : "string.Empty";
                    builder.AppendLine($"            {property.Name} = fields.TryGetValue(\"{key}\", out var {rawVariable}) ? {rawVariable} : {fallback},");
                    break;
                case PropertyValueKind.Boolean:
                    var boolFallback = property.IsNullable ? "null" : "false";
                    builder.AppendLine($"            {property.Name} = fields.TryGetValue(\"{key}\", out var {rawVariable}) && bool.TryParse({rawVariable}, out var {parsedVariable}) ? {parsedVariable} : {boolFallback},");
                    break;
                case PropertyValueKind.Int32:
                    var intFallback = property.IsNullable ? "null" : "0";
                    builder.AppendLine($"            {property.Name} = fields.TryGetValue(\"{key}\", out var {rawVariable}) && int.TryParse({rawVariable}, NumberStyles.Integer, CultureInfo.InvariantCulture, out var {parsedVariable}) ? {parsedVariable} : {intFallback},");
                    break;
                case PropertyValueKind.Double:
                    var doubleFallback = property.IsNullable ? "null" : "0d";
                    builder.AppendLine($"            {property.Name} = fields.TryGetValue(\"{key}\", out var {rawVariable}) && double.TryParse({rawVariable}, NumberStyles.Float, CultureInfo.InvariantCulture, out var {parsedVariable}) ? {parsedVariable} : {doubleFallback},");
                    break;
                case PropertyValueKind.Decimal:
                    var decimalFallback = property.IsNullable ? "null" : "0m";
                    builder.AppendLine($"            {property.Name} = fields.TryGetValue(\"{key}\", out var {rawVariable}) && decimal.TryParse({rawVariable}, NumberStyles.Float, CultureInfo.InvariantCulture, out var {parsedVariable}) ? {parsedVariable} : {decimalFallback},");
                    break;
                case PropertyValueKind.DateTime:
                    var dateTimeFallback = property.IsNullable ? "null" : "DateTime.MinValue";
                    builder.AppendLine($"            {property.Name} = fields.TryGetValue(\"{key}\", out var {rawVariable}) && DateTime.TryParse({rawVariable}, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal, out var {parsedVariable}) ? {parsedVariable} : {dateTimeFallback},");
                    break;
                case PropertyValueKind.DateTimeOffset:
                    var offsetFallback = property.IsNullable ? "null" : "DateTimeOffset.MinValue";
                    builder.AppendLine($"            {property.Name} = fields.TryGetValue(\"{key}\", out var {rawVariable}) && DateTimeOffset.TryParse({rawVariable}, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal, out var {parsedVariable}) ? {parsedVariable} : {offsetFallback},");
                    break;
                // NOTE: The parsing logic for StringArray and StringList expects comma-separated values in the frontmatter.
                // YAML array syntax (using '-' prefix for each item) is NOT supported here.
                // Example: tags: "foo, bar, baz"
                // NOT supported: tags:
                //   - foo
                //   - bar
                //   - baz
                case PropertyValueKind.StringArray:
                    var arrayFallback = property.IsNullable ? "null" : "System.Array.Empty<string>()";
                    builder.AppendLine($"            {property.Name} = fields.TryGetValue(\"{key}\", out var {rawVariable}) ? {rawVariable}.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries) : {arrayFallback},");
                    break;
                case PropertyValueKind.StringList:
                    var listFallback = property.IsNullable ? "null" : "new System.Collections.Generic.List<string>()";
                    builder.AppendLine($"            {property.Name} = fields.TryGetValue(\"{key}\", out var {rawVariable}) ? new System.Collections.Generic.List<string>({rawVariable}.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)) : {listFallback},");
                    break;
                default:
                    builder.AppendLine($"            {property.Name} = {property.DefaultValueExpression},");
                    break;
            }
        }
    }

    private static Regex? CreateGlobRegex(string pattern)
    {
        if (string.IsNullOrWhiteSpace(pattern))
        {
            return null;
        }

        var normalized = pattern.Trim().Replace('\\', '/');
        var sb = new StringBuilder();
        sb.Append('^');

        for (var i = 0; i < normalized.Length; i++)
        {
            var current = normalized[i];
            switch (current)
            {
                case '*':
                    var isDouble = i + 1 < normalized.Length && normalized[i + 1] == '*';
                    if (isDouble)
                    {
                        sb.Append(".*");
                        i++;
                    }
                    else
                    {
                        sb.Append("[^/]*");
                    }
                    break;
                case '?':
                    sb.Append("[^/]");
                    break;
                case '/':
                    sb.Append("/");
                    break;
                default:
                    if ("+()^$.{}![]|".IndexOf(current) >= 0)
                    {
                        sb.Append('\\');
                        sb.Append(current);
                    }
                    else
                    {
                        sb.Append(System.Text.RegularExpressions.Regex.Escape(current.ToString()));
                    }
                    break;
            }
        }

        sb.Append('$');
        return new Regex(sb.ToString(), RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant);
    }

    private static string ToPascalCase(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return string.Empty;
        }

        var parts = value.Split(new[] { '-', '_', ' ', '.' }, StringSplitOptions.RemoveEmptyEntries);
        var builder = new StringBuilder();
        foreach (var part in parts)
        {
            builder.Append(char.ToUpperInvariant(part[0]));
            if (part.Length > 1)
            {
                builder.Append(part.Substring(1));
            }
        }
        return builder.ToString();
    }

    private static string ToCamelCase(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return string.Empty;
        }

        if (value.Length == 1)
        {
            return value.ToLowerInvariant();
        }

        return char.ToLowerInvariant(value[0]) + value.Substring(1);
    }

    private static string EscapeForStringLiteral(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"");
    }

    private static CollectionDeclaration? CreateCollectionDeclaration(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        var attribute = context.Attributes.FirstOrDefault();
        if (attribute is null || attribute.ConstructorArguments.Length == 0)
        {
            return null;
        }

        var pattern = attribute.ConstructorArguments[0].Value as string;
        if (string.IsNullOrWhiteSpace(pattern))
        {
            return null;
        }

        var collectionName = attribute.NamedArguments.FirstOrDefault(arg => arg.Key == "Name").Value.Value as string;
        var fullyQualified = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(static prop => prop.DeclaredAccessibility == Accessibility.Public && !prop.IsStatic && prop.SetMethod is not null)
            .Select(CreatePropertyDescriptor)
            .Where(static descriptor => descriptor is not null)
            .Cast<PropertyDescriptor>()
            .ToImmutableArray();

        return new CollectionDeclaration(
            collectionName,
            typeSymbol.Name,
            pattern!,
            fullyQualified,
            properties,
            typeSymbol.Locations.FirstOrDefault() ?? Location.None);
    }

    private static PropertyDescriptor? CreatePropertyDescriptor(IPropertySymbol property)
    {
        var kind = GetPropertyKind(property);
        var frontMatterKey = ToCamelCase(property.Name);
        var isNullable = property.NullableAnnotation == NullableAnnotation.Annotated ||
                         (property.Type is INamedTypeSymbol named && named.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T);

        var defaultExpression = property.Type.IsReferenceType
            ? (property.NullableAnnotation == NullableAnnotation.Annotated ? "null" : "default!")
            : "default";

        return new PropertyDescriptor(
            property.Name,
            frontMatterKey,
            kind,
            isNullable,
            string.Equals(property.Name, "Slug", StringComparison.OrdinalIgnoreCase),
            string.Equals(property.Name, "Content", StringComparison.OrdinalIgnoreCase),
            defaultExpression);
    }

    private static PropertyValueKind GetPropertyKind(IPropertySymbol property)
    {
        var type = property.Type;
        if (type is INamedTypeSymbol named && named.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
        {
            type = named.TypeArguments[0];
        }

        if (type.SpecialType == SpecialType.System_String)
        {
            return PropertyValueKind.String;
        }

        if (type.SpecialType == SpecialType.System_Boolean ||
            string.Equals(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), "global::System.Boolean", StringComparison.Ordinal))
        {
            return PropertyValueKind.Boolean;
        }

        if (type.SpecialType == SpecialType.System_Int32 ||
            string.Equals(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), "global::System.Int32", StringComparison.Ordinal))
        {
            return PropertyValueKind.Int32;
        }

        if (type.SpecialType == SpecialType.System_Double ||
            string.Equals(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), "global::System.Double", StringComparison.Ordinal))
        {
            return PropertyValueKind.Double;
        }

        if (type.SpecialType == SpecialType.System_Decimal ||
            string.Equals(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), "global::System.Decimal", StringComparison.Ordinal))
        {
            return PropertyValueKind.Decimal;
        }

        if (type.SpecialType == SpecialType.System_DateTime ||
            string.Equals(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), "global::System.DateTime", StringComparison.Ordinal))
        {
            return PropertyValueKind.DateTime;
        }

        if (string.Equals(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), "global::System.DateTimeOffset", StringComparison.Ordinal))
        {
            return PropertyValueKind.DateTimeOffset;
        }

        if (property.Type is IArrayTypeSymbol array && array.ElementType.SpecialType == SpecialType.System_String)
        {
            return PropertyValueKind.StringArray;
        }

        if (IsStringEnumerable(property.Type))
        {
            return PropertyValueKind.StringList;
        }

        return PropertyValueKind.Unknown;
    }

    private static bool IsStringEnumerable(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol named || !named.IsGenericType)
        {
            return false;
        }

        if (named.TypeArguments.Length != 1 || named.TypeArguments[0].SpecialType != SpecialType.System_String)
        {
            return false;
        }

        var definition = named.ConstructedFrom.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return definition.Contains("IEnumerable", StringComparison.Ordinal) ||
               definition.Contains("IReadOnlyList", StringComparison.Ordinal) ||
               definition.Contains("IList", StringComparison.Ordinal) ||
               definition.Contains("List", StringComparison.Ordinal);
    }

    private static IReadOnlyList<ResolvedMarkdownFile> ResolveMarkdownFiles(ImmutableArray<MarkdownFile> files, string? projectDir, string rootNamespace)
    {
        var list = new List<ResolvedMarkdownFile>(files.Length);
        var normalizedProjectDir = string.IsNullOrWhiteSpace(projectDir) ? null : Path.GetFullPath(projectDir);

        foreach (var file in files)
        {
            var relative = NormalizeRelativePath(normalizedProjectDir, file.Path);
            var normalized = relative.Replace('\\', '/');
            if (normalized.StartsWith("./"))
            {
                normalized = normalized.Substring(2);
            }
            else if (normalized.StartsWith("/"))
            {
                normalized = normalized.Substring(1);
            }
            var slug = Path.GetFileNameWithoutExtension(file.Path) ?? "unknown";
            var suffix = normalized.Replace('/', '.');

            var componentNamespace = ComponentPathUtilities.GetComponentNamespace(rootNamespace, file.Path);
            var componentName = ComponentNameGenerator.Generate(Path.GetFileName(file.Path));
            var componentFullName = $"{componentNamespace}.{componentName}";

            list.Add(new ResolvedMarkdownFile(file.Path, normalized, suffix, slug, componentFullName));
        }

        return list;
    }

    private static string NormalizeRelativePath(string? projectDir, string filePath)
    {
        if (!string.IsNullOrWhiteSpace(projectDir))
        {
            var relative = GetRelativePathSafe(projectDir!, filePath);
            if (!string.IsNullOrWhiteSpace(relative))
            {
                return relative!;
            }
        }

        return Path.GetFileName(filePath) ?? filePath;
    }

    private static string? GetRelativePathSafe(string basePath, string targetPath)
    {
        try
        {
            var baseUri = new Uri(AppendDirectorySeparator(basePath));
            var targetUri = new Uri(targetPath);
            if (!string.Equals(baseUri.Scheme, targetUri.Scheme, StringComparison.OrdinalIgnoreCase))
            {
                return targetPath;
            }

            var relativeUri = baseUri.MakeRelativeUri(targetUri);
            var relativePath = Uri.UnescapeDataString(relativeUri.ToString());
            return relativePath.Replace('/', Path.DirectorySeparatorChar);
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"GetRelativePathSafe error: {ex}");
            return targetPath;
        }
    }

    private static string AppendDirectorySeparator(string path)
    {
        if (string.IsNullOrEmpty(path))
        {
            return path;
        }

        return path.EndsWith(Path.DirectorySeparatorChar.ToString(), StringComparison.Ordinal)
            ? path
            : path + Path.DirectorySeparatorChar;
    }

    private readonly record struct MarkdownFile(string Path);

    private readonly record struct ResolvedMarkdownFile(
        string AbsolutePath,
        string NormalizedRelativePath,
        string ResourceSuffix,
        string Slug,
        string ComponentFullTypeName);

    private readonly record struct ProjectInfo(string? ProjectDir, string? RootNamespace);

    private sealed record CollectionDeclaration(
        string? CollectionName,
        string TypeSymbolName,
        string GlobPattern,
        string FullyQualifiedTypeName,
        ImmutableArray<PropertyDescriptor> Properties,
        Location Location)
    {
        public static IEqualityComparer<CollectionDeclaration> Comparer { get; } = new DeclarationComparer();
    }

    private sealed class DeclarationComparer : IEqualityComparer<CollectionDeclaration>
    {
        public bool Equals(CollectionDeclaration? x, CollectionDeclaration? y)
        {
            if (ReferenceEquals(x, y))
            {
                return true;
            }

            if (x is null || y is null)
            {
                return false;
            }

            return x.FullyQualifiedTypeName == y.FullyQualifiedTypeName &&
                   x.GlobPattern == y.GlobPattern;
        }

        public int GetHashCode(CollectionDeclaration obj)
        {
            unchecked
            {
                var hash = StringComparer.Ordinal.GetHashCode(obj.FullyQualifiedTypeName ?? string.Empty);
                // Use a prime number (397) to reduce hash collisions and improve distribution.
                hash = (hash * 397) ^ StringComparer.Ordinal.GetHashCode(obj.GlobPattern ?? string.Empty);
                return hash;
            }
        }
    }

    private sealed record PropertyDescriptor(
        string Name,
        string FrontMatterKey,
        PropertyValueKind Kind,
        bool IsNullable,
        bool IsSlug,
        bool IsContent,
        string DefaultValueExpression);

    private enum PropertyValueKind
    {
        Unknown,
        String,
        Boolean,
        Int32,
        Double,
        Decimal,
        DateTime,
        DateTimeOffset,
        StringArray,
        StringList
    }

    private static class Descriptors
    {
        public static readonly DiagnosticDescriptor InvalidGlobPattern = new(
            "MDCC003",
            "Invalid collection glob pattern",
            "The glob pattern '{0}' could not be parsed.",
            "ContentCollections",
            DiagnosticSeverity.Warning,
            true);

        public static readonly DiagnosticDescriptor NoMatchingMarkdownFiles = new(
            "MDCC004",
            "No markdown files matched the glob pattern",
            "No markdown files were found for glob pattern '{0}'.",
            "ContentCollections",
            DiagnosticSeverity.Info,
            true);
    }
}
