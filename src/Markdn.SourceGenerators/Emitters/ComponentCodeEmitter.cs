using System;
using System.Collections.Generic;
using System.Text;
using Markdn.SourceGenerators.Models;

namespace Markdn.SourceGenerators.Emitters;

/// <summary>
/// Emits C# source code for Blazor components from ComponentMetadata.
/// Handles class structure, namespace, attributes, inheritance, and parameters.
/// </summary>
public static class ComponentCodeEmitter
{
    /// <summary>
    /// Determine if a type is a reference type (needs = default! initialization)
    /// </summary>
    private static bool IsReferenceType(string typeName)
    {
        // Common value types that don't need = default!
        var valueTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "bool", "byte", "sbyte", "char", "decimal", "double", "float", "int", "uint",
            "long", "ulong", "short", "ushort", "nint", "nuint",
            "System.Boolean", "System.Byte", "System.SByte", "System.Char", "System.Decimal",
            "System.Double", "System.Single", "System.Int32", "System.UInt32", "System.Int64",
            "System.UInt64", "System.Int16", "System.UInt16", "System.IntPtr", "System.UIntPtr"
        };

        // If it's a known value type, it's not a reference type
        if (valueTypes.Contains(typeName))
        {
            return false;
        }

        // If it ends with ?, it's a nullable value type, still not a reference type
        if (typeName.EndsWith("?"))
        {
            return false;
        }

        // Everything else is assumed to be a reference type
        // This includes string, custom classes, interfaces, etc.
        return true;
    }
    /// <summary>
    /// Generate complete component source code.
    /// </summary>
    /// <param name="componentName">Component class name</param>
    /// <param name="namespaceValue">Namespace for the component</param>
    /// <param name="htmlContent">Rendered HTML content</param>
    /// <param name="metadata">Component metadata from YAML front matter</param>
    /// <param name="codeBlocks">Extracted @code blocks</param>
    /// <returns>Complete C# source code</returns>
    public static string Emit(
        string componentName,
        string namespaceValue,
        string htmlContent,
        ComponentMetadata metadata,
        List<CodeBlock>? codeBlocks = null,
        Dictionary<string, string>? componentTypeMap = null,
        IEnumerable<string>? availableNamespaces = null)
    {
        var sb = new StringBuilder();
        
        // File header
        sb.AppendLine("// <auto-generated by Markdn.SourceGenerators v1.0.0 />");
        sb.AppendLine("// This file is auto-generated. Do not edit directly.");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

    // NOTE: we may emit lightweight using directives for namespaces that are
    // known to exist in the current compilation (availableNamespaces). This
    // keeps generated files readable and avoids hard-coding a single
    // project-specific namespace while still enabling simple type lookup when
    // available.
    sb.AppendLine();

        // Using directives (from generator-discovered available namespaces)
        if (availableNamespaces != null)
        {
            foreach (var ns in availableNamespaces)
            {
                if (!string.IsNullOrWhiteSpace(ns))
                {
                    sb.AppendLine($"using {ns};");
                }
            }
            sb.AppendLine();
        }

        // Ensure the parent namespace of the generated component is available as a using
        // This helps resolve sibling components (e.g., Counter in Pages) without
        // requiring the generator to perfectly discover every type's namespace.
        if (!string.IsNullOrWhiteSpace(namespaceValue))
        {
            var lastDot = namespaceValue.LastIndexOf('.');
            if (lastDot > 0)
            {
                var parentNs = namespaceValue.Substring(0, lastDot);
                if (!string.IsNullOrWhiteSpace(parentNs))
                {
                    sb.AppendLine($"using {parentNs};");
                    sb.AppendLine();
                }
            }
        }

        // Using directives (from metadata)
        if (metadata.Using != null && metadata.Using.Count > 0)
        {
            foreach (var usingDirective in metadata.Using)
            {
                sb.AppendLine($"using {usingDirective};");
            }
            sb.AppendLine();
        }

        // Namespace
        sb.AppendLine($"namespace {namespaceValue}");
        sb.AppendLine("{");

        // Route attributes (T046, T047: from metadata Url/UrlArray)
        if (!string.IsNullOrEmpty(metadata.Url))
        {
            sb.AppendLine($"    [Microsoft.AspNetCore.Components.RouteAttribute(\"{metadata.Url}\")]");
        }
        else if (metadata.UrlArray != null && metadata.UrlArray.Count > 0)
        {
            foreach (var url in metadata.UrlArray)
            {
                sb.AppendLine($"    [Microsoft.AspNetCore.Components.RouteAttribute(\"{url}\")]");
            }
        }

        // T091: Layout attribute (from metadata)
        if (!string.IsNullOrEmpty(metadata.Layout))
        {
            sb.AppendLine($"    [Microsoft.AspNetCore.Components.LayoutAttribute(typeof({metadata.Layout}))]");
        }

        // Class attributes (from metadata)
        if (metadata.Attribute != null && metadata.Attribute.Count > 0)
        {
            foreach (var attribute in metadata.Attribute)
            {
                sb.AppendLine($"    [{attribute}]");
            }
        }

        // Class declaration with inheritance
        var baseClass = metadata.Inherit ?? "Microsoft.AspNetCore.Components.ComponentBase";
        sb.AppendLine($"    public partial class {componentName} : {baseClass}");
        sb.AppendLine("    {");

        // Component parameters
        if (metadata.Parameters != null && metadata.Parameters.Count > 0)
        {
            foreach (var parameter in metadata.Parameters)
            {
                sb.AppendLine("        [Microsoft.AspNetCore.Components.Parameter]");
                var defaultValue = IsReferenceType(parameter.Type) ? " = default!;" : "";
                sb.AppendLine($"        public {parameter.Type} {parameter.Name} {{ get; set; }}{defaultValue}");
                sb.AppendLine();
            }
        }

    // BuildRenderTree method (using RenderTreeBuilderEmitter)
    sb.Append(RenderTreeBuilderEmitter.EmitBuildRenderTree(htmlContent, metadata, componentTypeMap, indentLevel: 2));

        // T059: Emit @code blocks after BuildRenderTree method
        if (codeBlocks != null && codeBlocks.Count > 0)
        {
            sb.AppendLine();
            sb.AppendLine("        // Code blocks from Markdown");
            
            foreach (var codeBlock in codeBlocks)
            {
                // Indent each line of the code block
                var lines = codeBlock.Content.Split(new[] { "\r\n", "\r", "\n" }, System.StringSplitOptions.None);
                foreach (var line in lines)
                {
                    sb.AppendLine($"        {line}");
                }
            }
        }

        // Close class and namespace
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Generate simple component source (legacy method for backward compatibility).
    /// </summary>
    public static string EmitSimple(
        string componentName,
        string namespaceValue,
        string htmlContent)
    {
        return Emit(componentName, namespaceValue, htmlContent, ComponentMetadata.Empty, null, null);
    }
}
